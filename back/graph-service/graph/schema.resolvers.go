package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.42

import (
	"context"
	"errors"

	"github.com/0x726f6f6b6965/my-blog/graph-service/internal/middleware"
	"github.com/0x726f6f6b6965/my-blog/graph-service/internal/model"
	"github.com/0x726f6f6b6965/my-blog/lib/checker"
	pbBlog "github.com/0x726f6f6b6965/my-blog/protos/blog/v1"
	pbSearch "github.com/0x726f6f6b6965/my-blog/protos/search/v1"
	pbUser "github.com/0x726f6f6b6965/my-blog/protos/user/v1"
	"go.uber.org/zap"
	"google.golang.org/protobuf/types/known/fieldmaskpb"
)

// Register is the resolver for the register field.
func (r *mutationResolver) Register(ctx context.Context, input model.NewUser) (string, error) {
	resp, err := r.UserService.CreateUser(ctx, &pbUser.CreateUserRequest{
		Username: input.Username, Email: input.Email, Password: input.Password})
	if err != nil {
		r.Log.Error("Register failed", zap.Error(err))
		return "", errors.New("registration failed")
	}
	return resp.GetToken(), nil
}

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, input model.LoginInput) (string, error) {
	resp, err := r.UserService.GetToken(ctx, &pbUser.GetTokenRequest{
		Email: input.Email, Password: input.Password})
	if err != nil {
		r.Log.Error("Login failed", zap.Error(err))
		return "", errors.New("login failed, invalid email or password")
	}
	return resp.GetToken(), nil
}

// NewBlog is the resolver for the newBlog field.
func (r *mutationResolver) NewBlog(ctx context.Context, input model.NewBlog) (*model.Blog, error) {
	email := middleware.ForContext(ctx)
	// if the user does not exist, return an error
	if checker.IsEmpty(email) {
		return &model.Blog{}, errors.New("access denied")
	}
	resp, err := r.BlogService.CreateBlog(ctx, &pbBlog.CreateBlogRequest{
		Title: input.Title, Content: input.Content, Author: email})
	if err != nil {
		r.Log.Error("NewBlog failed", zap.Error(err))
		return &model.Blog{}, errors.New("access denied")
	}
	blog := &model.Blog{
		ID:      resp.Id,
		Title:   resp.Title,
		Content: resp.Content,
		Author: &model.User{
			Email: resp.Author,
		},
		CreatedAt: resp.CreateTime.AsTime(),
		UpdatedAt: resp.UpdateTime.AsTime(),
	}
	return blog, nil
}

// EditBlog is the resolver for the editBlog field.
func (r *mutationResolver) EditBlog(ctx context.Context, input model.EditBlog) (*model.Blog, error) {
	email := middleware.ForContext(ctx)
	// if the user does not exist, return an error
	if checker.IsEmpty(email) {
		return &model.Blog{}, errors.New("access denied")
	}
	if checker.IsEmpty(input.BlogID) {
		return &model.Blog{}, errors.New("access denied")
	}
	req := &pbBlog.EditBlogRequest{
		Id:         input.BlogID,
		UpdateMask: &fieldmaskpb.FieldMask{}}
	blog := &pbBlog.Blog{Author: email}
	if checker.IsEmpty(input.Content) {
		blog.Content = input.Content
		req.UpdateMask.Paths = append(req.UpdateMask.Paths, "blog.content")
	}
	if checker.IsEmpty(input.Title) {
		blog.Title = input.Title
		req.UpdateMask.Paths = append(req.UpdateMask.Paths, "blog.title")
	}
	req.Blog = blog

	blog, err := r.BlogService.EditBlog(ctx, req)
	if err != nil {
		r.Log.Error("EditBlog failed", zap.Error(err))
		return &model.Blog{}, errors.New("access denied")
	}
	resp := &model.Blog{
		ID:      blog.Id,
		Title:   blog.Title,
		Content: blog.Content,
		Author: &model.User{
			Email: email,
		},
		CreatedAt: blog.CreateTime.AsTime(),
		UpdatedAt: blog.UpdateTime.AsTime(),
	}
	return resp, nil
}

// DeleteBlog is the resolver for the deleteBlog field.
func (r *mutationResolver) DeleteBlog(ctx context.Context, input model.DeleteBlog) (bool, error) {
	email := middleware.ForContext(ctx)
	// if the user does not exist, return an error
	if checker.IsEmpty(email) {
		return false, errors.New("access denied")
	}
	_, err := r.BlogService.DeleteBlog(ctx, &pbBlog.DeleteBlogRequest{Id: input.BlogID, Author: email})
	if err != nil {
		r.Log.Error("DeleteBlog failed", zap.Error(err))
		return false, errors.New("access denied")
	}
	return true, nil
}

// Blogs is the resolver for the blogs field.
func (r *queryResolver) Blogs(ctx context.Context, input model.GetBlogs) (*model.ListBlog, error) {
	resp, err := r.BlogService.GetBlogList(ctx, &pbBlog.GetBlogListRequest{
		PageSize:  int32(input.PageSize),
		PageToken: input.PageToken,
		Authors:   input.Authors,
	})
	if err != nil {
		r.Log.Error("Blogs failed", zap.Error(err))
		return &model.ListBlog{}, errors.New("access denied")
	}
	result := &model.ListBlog{
		NextToken: resp.NextToken,
	}
	for _, data := range resp.Blog {
		result.Blogs = append(result.Blogs, &model.Blog{
			ID:      data.Id,
			Title:   data.Title,
			Content: data.Content,
			Author: &model.User{
				Email: data.Author,
			},
			CreatedAt: data.CreateTime.AsTime(),
			UpdatedAt: data.UpdateTime.AsTime(),
		})
	}
	return result, nil
}

// Blog is the resolver for the blog field.
func (r *queryResolver) Blog(ctx context.Context, id string) (*model.Blog, error) {
	resp, err := r.BlogService.GetBlog(ctx, &pbBlog.GetBlogRequest{Id: id})
	if err != nil {
		r.Log.Error("Blog failed", zap.Error(err))
		return &model.Blog{}, errors.New("access denied")
	}
	blog := &model.Blog{
		ID:      resp.Id,
		Title:   resp.Title,
		Content: resp.Content,
		Author: &model.User{
			Email: resp.Author,
		},
		CreatedAt: resp.CreateTime.AsTime(),
		UpdatedAt: resp.UpdateTime.AsTime(),
	}
	return blog, nil
}

// Title is the resolver for the title field.
func (r *queryResolver) Title(ctx context.Context, input string) ([]string, error) {
	resp, err := r.SearchService.AutoComplete(ctx, &pbSearch.AutoCompleteRequest{Words: input})
	if err != nil {
		r.Log.Error("Title failed", zap.Error(err))
		return []string{}, errors.New("access denied")
	}
	return resp.Match, nil
}

// BlogID is the resolver for the blogId field.
func (r *queryResolver) BlogID(ctx context.Context, input string) ([]string, error) {
	resp, err := r.SearchService.Search(ctx, &pbSearch.SearchRequest{Query: input})
	if err != nil {
		r.Log.Error("BlogID failed", zap.Error(err))
		return []string{}, errors.New("access denied")
	}
	return resp.GetIds(), nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
